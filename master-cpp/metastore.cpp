#include "metastore.h"
#include <sstream>
#include <stdexcept>
static const char* kCreate = "CREATE TABLE IF NOT EXISTS file_blocks (filename TEXT, idx INTEGER, block_id TEXT, primary_dn TEXT, replicas_csv TEXT, PRIMARY KEY(filename,idx));";
static const char* kInsert = "INSERT OR REPLACE INTO file_blocks(filename,idx,block_id,primary_dn,replicas_csv) VALUES(?1,?2,?3,?4,?5);";
static const char* kQuery = "SELECT filename,idx,block_id,primary_dn,replicas_csv FROM file_blocks WHERE filename=?1 ORDER BY idx;";
MetaStore::MetaStore(const std::string& db){ if(sqlite3_open(db.c_str(),&db_)!=SQLITE_OK) throw std::runtime_error("No metadb"); InitSchema(); }
MetaStore::~MetaStore(){ if(db_) sqlite3_close(db_);}
void MetaStore::InitSchema(){ char* err=nullptr; if(sqlite3_exec(db_,kCreate,nullptr,nullptr,&err)!=SQLITE_OK){ std::string m=err?err:"err"; sqlite3_free(err); throw std::runtime_error(m);} }
void MetaStore::SavePutPlan(const std::string& fn,const std::vector<gridfs::BlockAssignment>& asgs){ sqlite3_exec(db_,"BEGIN;",nullptr,nullptr,nullptr); sqlite3_stmt* s=nullptr; sqlite3_prepare_v2(db_,kInsert,-1,&s,nullptr); for(size_t i=0;i<asgs.size();++i){ const auto& a=asgs[i]; std::ostringstream csv; for(int j=0;j<a.replica_dns_size();++j){ if(j) csv<<","; csv<<a.replica_dns(j);} sqlite3_bind_text(s,1,fn.c_str(),-1,SQLITE_TRANSIENT); sqlite3_bind_int64(s,2,(sqlite3_int64)i); sqlite3_bind_text(s,3,a.block_id().c_str(),-1,SQLITE_TRANSIENT); sqlite3_bind_text(s,4,a.primary_dn().c_str(),-1,SQLITE_TRANSIENT); auto scsv=csv.str(); sqlite3_bind_text(s,5,scsv.c_str(),-1,SQLITE_TRANSIENT); if(sqlite3_step(s)!=SQLITE_DONE){ sqlite3_finalize(s); sqlite3_exec(db_,"ROLLBACK;",nullptr,nullptr,nullptr); throw std::runtime_error("insert fail"); } sqlite3_reset(s);} sqlite3_finalize(s); sqlite3_exec(db_,"COMMIT;",nullptr,nullptr,nullptr); }
std::vector<FileBlockRow> MetaStore::GetFileLayout(const std::string& fn){ sqlite3_stmt* s=nullptr; sqlite3_prepare_v2(db_,kQuery,-1,&s,nullptr); sqlite3_bind_text(s,1,fn.c_str(),-1,SQLITE_TRANSIENT); std::vector<FileBlockRow> v; int rc; while((rc=sqlite3_step(s))==SQLITE_ROW){ FileBlockRow r; r.filename=(const char*)sqlite3_column_text(s,0); r.idx=sqlite3_column_int64(s,1); r.block_id=(const char*)sqlite3_column_text(s,2); r.primary_dn=(const char*)sqlite3_column_text(s,3); r.replicas_csv=(const char*)sqlite3_column_text(s,4); v.push_back(std::move(r)); } sqlite3_finalize(s); return v; }