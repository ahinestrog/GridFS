// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_common_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_common_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_common_2eproto;
namespace gridfs {
class BlockAssignment;
struct BlockAssignmentDefaultTypeInternal;
extern BlockAssignmentDefaultTypeInternal _BlockAssignment_default_instance_;
class BlockChunk;
struct BlockChunkDefaultTypeInternal;
extern BlockChunkDefaultTypeInternal _BlockChunk_default_instance_;
class BlockId;
struct BlockIdDefaultTypeInternal;
extern BlockIdDefaultTypeInternal _BlockId_default_instance_;
class BlockLocation;
struct BlockLocationDefaultTypeInternal;
extern BlockLocationDefaultTypeInternal _BlockLocation_default_instance_;
class FsEntry;
struct FsEntryDefaultTypeInternal;
extern FsEntryDefaultTypeInternal _FsEntry_default_instance_;
class FsOpRequest;
struct FsOpRequestDefaultTypeInternal;
extern FsOpRequestDefaultTypeInternal _FsOpRequest_default_instance_;
class FsOpResponse;
struct FsOpResponseDefaultTypeInternal;
extern FsOpResponseDefaultTypeInternal _FsOpResponse_default_instance_;
class HeartbeatAck;
struct HeartbeatAckDefaultTypeInternal;
extern HeartbeatAckDefaultTypeInternal _HeartbeatAck_default_instance_;
class HeartbeatKv;
struct HeartbeatKvDefaultTypeInternal;
extern HeartbeatKvDefaultTypeInternal _HeartbeatKv_default_instance_;
class WriteAck;
struct WriteAckDefaultTypeInternal;
extern WriteAckDefaultTypeInternal _WriteAck_default_instance_;
}  // namespace gridfs
PROTOBUF_NAMESPACE_OPEN
template<> ::gridfs::BlockAssignment* Arena::CreateMaybeMessage<::gridfs::BlockAssignment>(Arena*);
template<> ::gridfs::BlockChunk* Arena::CreateMaybeMessage<::gridfs::BlockChunk>(Arena*);
template<> ::gridfs::BlockId* Arena::CreateMaybeMessage<::gridfs::BlockId>(Arena*);
template<> ::gridfs::BlockLocation* Arena::CreateMaybeMessage<::gridfs::BlockLocation>(Arena*);
template<> ::gridfs::FsEntry* Arena::CreateMaybeMessage<::gridfs::FsEntry>(Arena*);
template<> ::gridfs::FsOpRequest* Arena::CreateMaybeMessage<::gridfs::FsOpRequest>(Arena*);
template<> ::gridfs::FsOpResponse* Arena::CreateMaybeMessage<::gridfs::FsOpResponse>(Arena*);
template<> ::gridfs::HeartbeatAck* Arena::CreateMaybeMessage<::gridfs::HeartbeatAck>(Arena*);
template<> ::gridfs::HeartbeatKv* Arena::CreateMaybeMessage<::gridfs::HeartbeatKv>(Arena*);
template<> ::gridfs::WriteAck* Arena::CreateMaybeMessage<::gridfs::WriteAck>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace gridfs {

enum FsOpRequest_Op : int {
  FsOpRequest_Op_LS = 0,
  FsOpRequest_Op_RM = 1,
  FsOpRequest_Op_MKDIR = 2,
  FsOpRequest_Op_RMDIR = 3,
  FsOpRequest_Op_FsOpRequest_Op_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FsOpRequest_Op_FsOpRequest_Op_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FsOpRequest_Op_IsValid(int value);
constexpr FsOpRequest_Op FsOpRequest_Op_Op_MIN = FsOpRequest_Op_LS;
constexpr FsOpRequest_Op FsOpRequest_Op_Op_MAX = FsOpRequest_Op_RMDIR;
constexpr int FsOpRequest_Op_Op_ARRAYSIZE = FsOpRequest_Op_Op_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FsOpRequest_Op_descriptor();
template<typename T>
inline const std::string& FsOpRequest_Op_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FsOpRequest_Op>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FsOpRequest_Op_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FsOpRequest_Op_descriptor(), enum_t_value);
}
inline bool FsOpRequest_Op_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FsOpRequest_Op* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FsOpRequest_Op>(
    FsOpRequest_Op_descriptor(), name, value);
}
// ===================================================================

class BlockAssignment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.BlockAssignment) */ {
 public:
  inline BlockAssignment() : BlockAssignment(nullptr) {}
  ~BlockAssignment() override;
  explicit PROTOBUF_CONSTEXPR BlockAssignment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockAssignment(const BlockAssignment& from);
  BlockAssignment(BlockAssignment&& from) noexcept
    : BlockAssignment() {
    *this = ::std::move(from);
  }

  inline BlockAssignment& operator=(const BlockAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockAssignment& operator=(BlockAssignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockAssignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockAssignment* internal_default_instance() {
    return reinterpret_cast<const BlockAssignment*>(
               &_BlockAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BlockAssignment& a, BlockAssignment& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockAssignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockAssignment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockAssignment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockAssignment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockAssignment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockAssignment& from) {
    BlockAssignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockAssignment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.BlockAssignment";
  }
  protected:
  explicit BlockAssignment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicaDnsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kPrimaryDnFieldNumber = 2,
  };
  // repeated string replica_dns = 3;
  int replica_dns_size() const;
  private:
  int _internal_replica_dns_size() const;
  public:
  void clear_replica_dns();
  const std::string& replica_dns(int index) const;
  std::string* mutable_replica_dns(int index);
  void set_replica_dns(int index, const std::string& value);
  void set_replica_dns(int index, std::string&& value);
  void set_replica_dns(int index, const char* value);
  void set_replica_dns(int index, const char* value, size_t size);
  std::string* add_replica_dns();
  void add_replica_dns(const std::string& value);
  void add_replica_dns(std::string&& value);
  void add_replica_dns(const char* value);
  void add_replica_dns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replica_dns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replica_dns();
  private:
  const std::string& _internal_replica_dns(int index) const;
  std::string* _internal_add_replica_dns();
  public:

  // string block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_NODISCARD std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // string primary_dn = 2;
  void clear_primary_dn();
  const std::string& primary_dn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_dn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_dn();
  PROTOBUF_NODISCARD std::string* release_primary_dn();
  void set_allocated_primary_dn(std::string* primary_dn);
  private:
  const std::string& _internal_primary_dn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_dn(const std::string& value);
  std::string* _internal_mutable_primary_dn();
  public:

  // @@protoc_insertion_point(class_scope:gridfs.BlockAssignment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replica_dns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_dn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class BlockLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.BlockLocation) */ {
 public:
  inline BlockLocation() : BlockLocation(nullptr) {}
  ~BlockLocation() override;
  explicit PROTOBUF_CONSTEXPR BlockLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockLocation(const BlockLocation& from);
  BlockLocation(BlockLocation&& from) noexcept
    : BlockLocation() {
    *this = ::std::move(from);
  }

  inline BlockLocation& operator=(const BlockLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockLocation& operator=(BlockLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockLocation* internal_default_instance() {
    return reinterpret_cast<const BlockLocation*>(
               &_BlockLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BlockLocation& a, BlockLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockLocation& from) {
    BlockLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.BlockLocation";
  }
  protected:
  explicit BlockLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicaDnsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kPrimaryDnFieldNumber = 2,
  };
  // repeated string replica_dns = 3;
  int replica_dns_size() const;
  private:
  int _internal_replica_dns_size() const;
  public:
  void clear_replica_dns();
  const std::string& replica_dns(int index) const;
  std::string* mutable_replica_dns(int index);
  void set_replica_dns(int index, const std::string& value);
  void set_replica_dns(int index, std::string&& value);
  void set_replica_dns(int index, const char* value);
  void set_replica_dns(int index, const char* value, size_t size);
  std::string* add_replica_dns();
  void add_replica_dns(const std::string& value);
  void add_replica_dns(std::string&& value);
  void add_replica_dns(const char* value);
  void add_replica_dns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& replica_dns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_replica_dns();
  private:
  const std::string& _internal_replica_dns(int index) const;
  std::string* _internal_add_replica_dns();
  public:

  // string block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_NODISCARD std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // string primary_dn = 2;
  void clear_primary_dn();
  const std::string& primary_dn() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_primary_dn(ArgT0&& arg0, ArgT... args);
  std::string* mutable_primary_dn();
  PROTOBUF_NODISCARD std::string* release_primary_dn();
  void set_allocated_primary_dn(std::string* primary_dn);
  private:
  const std::string& _internal_primary_dn() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_primary_dn(const std::string& value);
  std::string* _internal_mutable_primary_dn();
  public:

  // @@protoc_insertion_point(class_scope:gridfs.BlockLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> replica_dns_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr primary_dn_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class BlockChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.BlockChunk) */ {
 public:
  inline BlockChunk() : BlockChunk(nullptr) {}
  ~BlockChunk() override;
  explicit PROTOBUF_CONSTEXPR BlockChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockChunk(const BlockChunk& from);
  BlockChunk(BlockChunk&& from) noexcept
    : BlockChunk() {
    *this = ::std::move(from);
  }

  inline BlockChunk& operator=(const BlockChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockChunk& operator=(BlockChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockChunk* internal_default_instance() {
    return reinterpret_cast<const BlockChunk*>(
               &_BlockChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BlockChunk& a, BlockChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockChunk& from) {
    BlockChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.BlockChunk";
  }
  protected:
  explicit BlockChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kDataFieldNumber = 3,
    kSeqFieldNumber = 2,
    kEofFieldNumber = 4,
  };
  // string block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_NODISCARD std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes data = 3;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 seq = 2;
  void clear_seq();
  int64_t seq() const;
  void set_seq(int64_t value);
  private:
  int64_t _internal_seq() const;
  void _internal_set_seq(int64_t value);
  public:

  // bool eof = 4;
  void clear_eof();
  bool eof() const;
  void set_eof(bool value);
  private:
  bool _internal_eof() const;
  void _internal_set_eof(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.BlockChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t seq_;
    bool eof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class WriteAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.WriteAck) */ {
 public:
  inline WriteAck() : WriteAck(nullptr) {}
  ~WriteAck() override;
  explicit PROTOBUF_CONSTEXPR WriteAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteAck(const WriteAck& from);
  WriteAck(WriteAck&& from) noexcept
    : WriteAck() {
    *this = ::std::move(from);
  }

  inline WriteAck& operator=(const WriteAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteAck& operator=(WriteAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteAck* internal_default_instance() {
    return reinterpret_cast<const WriteAck*>(
               &_WriteAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WriteAck& a, WriteAck& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteAck& from) {
    WriteAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.WriteAck";
  }
  protected:
  explicit WriteAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kChecksumFieldNumber = 3,
    kMessageFieldNumber = 5,
    kBytesReceivedFieldNumber = 2,
    kOkFieldNumber = 4,
  };
  // string block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_NODISCARD std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // string checksum = 3;
  void clear_checksum();
  const std::string& checksum() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_checksum(ArgT0&& arg0, ArgT... args);
  std::string* mutable_checksum();
  PROTOBUF_NODISCARD std::string* release_checksum();
  void set_allocated_checksum(std::string* checksum);
  private:
  const std::string& _internal_checksum() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_checksum(const std::string& value);
  std::string* _internal_mutable_checksum();
  public:

  // string message = 5;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 bytes_received = 2;
  void clear_bytes_received();
  int64_t bytes_received() const;
  void set_bytes_received(int64_t value);
  private:
  int64_t _internal_bytes_received() const;
  void _internal_set_bytes_received(int64_t value);
  public:

  // bool ok = 4;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.WriteAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr checksum_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int64_t bytes_received_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class BlockId final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.BlockId) */ {
 public:
  inline BlockId() : BlockId(nullptr) {}
  ~BlockId() override;
  explicit PROTOBUF_CONSTEXPR BlockId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockId(const BlockId& from);
  BlockId(BlockId&& from) noexcept
    : BlockId() {
    *this = ::std::move(from);
  }

  inline BlockId& operator=(const BlockId& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockId& operator=(BlockId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockId& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockId* internal_default_instance() {
    return reinterpret_cast<const BlockId*>(
               &_BlockId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlockId& a, BlockId& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockId>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockId& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockId& from) {
    BlockId::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.BlockId";
  }
  protected:
  explicit BlockId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
  };
  // string block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_NODISCARD std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // @@protoc_insertion_point(class_scope:gridfs.BlockId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatKv final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.HeartbeatKv) */ {
 public:
  inline HeartbeatKv() : HeartbeatKv(nullptr) {}
  ~HeartbeatKv() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatKv(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatKv(const HeartbeatKv& from);
  HeartbeatKv(HeartbeatKv&& from) noexcept
    : HeartbeatKv() {
    *this = ::std::move(from);
  }

  inline HeartbeatKv& operator=(const HeartbeatKv& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatKv& operator=(HeartbeatKv&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatKv& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatKv* internal_default_instance() {
    return reinterpret_cast<const HeartbeatKv*>(
               &_HeartbeatKv_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartbeatKv& a, HeartbeatKv& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatKv* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatKv* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatKv* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatKv>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatKv& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatKv& from) {
    HeartbeatKv::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatKv* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.HeartbeatKv";
  }
  protected:
  explicit HeartbeatKv(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kKeyFieldNumber = 2,
    kValueFieldNumber = 3,
    kTsUnixMsFieldNumber = 4,
  };
  // string node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_node_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // string key = 2;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string value = 3;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // int64 ts_unix_ms = 4;
  void clear_ts_unix_ms();
  int64_t ts_unix_ms() const;
  void set_ts_unix_ms(int64_t value);
  private:
  int64_t _internal_ts_unix_ms() const;
  void _internal_set_ts_unix_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.HeartbeatKv)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int64_t ts_unix_ms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.HeartbeatAck) */ {
 public:
  inline HeartbeatAck() : HeartbeatAck(nullptr) {}
  ~HeartbeatAck() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatAck(const HeartbeatAck& from);
  HeartbeatAck(HeartbeatAck&& from) noexcept
    : HeartbeatAck() {
    *this = ::std::move(from);
  }

  inline HeartbeatAck& operator=(const HeartbeatAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatAck& operator=(HeartbeatAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatAck* internal_default_instance() {
    return reinterpret_cast<const HeartbeatAck*>(
               &_HeartbeatAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HeartbeatAck& a, HeartbeatAck& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatAck& from) {
    HeartbeatAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.HeartbeatAck";
  }
  protected:
  explicit HeartbeatAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.HeartbeatAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class FsOpRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.FsOpRequest) */ {
 public:
  inline FsOpRequest() : FsOpRequest(nullptr) {}
  ~FsOpRequest() override;
  explicit PROTOBUF_CONSTEXPR FsOpRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FsOpRequest(const FsOpRequest& from);
  FsOpRequest(FsOpRequest&& from) noexcept
    : FsOpRequest() {
    *this = ::std::move(from);
  }

  inline FsOpRequest& operator=(const FsOpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsOpRequest& operator=(FsOpRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FsOpRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FsOpRequest* internal_default_instance() {
    return reinterpret_cast<const FsOpRequest*>(
               &_FsOpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FsOpRequest& a, FsOpRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FsOpRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FsOpRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FsOpRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FsOpRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FsOpRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FsOpRequest& from) {
    FsOpRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsOpRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.FsOpRequest";
  }
  protected:
  explicit FsOpRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FsOpRequest_Op Op;
  static constexpr Op LS =
    FsOpRequest_Op_LS;
  static constexpr Op RM =
    FsOpRequest_Op_RM;
  static constexpr Op MKDIR =
    FsOpRequest_Op_MKDIR;
  static constexpr Op RMDIR =
    FsOpRequest_Op_RMDIR;
  static inline bool Op_IsValid(int value) {
    return FsOpRequest_Op_IsValid(value);
  }
  static constexpr Op Op_MIN =
    FsOpRequest_Op_Op_MIN;
  static constexpr Op Op_MAX =
    FsOpRequest_Op_Op_MAX;
  static constexpr int Op_ARRAYSIZE =
    FsOpRequest_Op_Op_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Op_descriptor() {
    return FsOpRequest_Op_descriptor();
  }
  template<typename T>
  static inline const std::string& Op_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Op>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Op_Name.");
    return FsOpRequest_Op_Name(enum_t_value);
  }
  static inline bool Op_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Op* value) {
    return FsOpRequest_Op_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kOpFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // .gridfs.FsOpRequest.Op op = 1;
  void clear_op();
  ::gridfs::FsOpRequest_Op op() const;
  void set_op(::gridfs::FsOpRequest_Op value);
  private:
  ::gridfs::FsOpRequest_Op _internal_op() const;
  void _internal_set_op(::gridfs::FsOpRequest_Op value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.FsOpRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
    int op_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class FsEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.FsEntry) */ {
 public:
  inline FsEntry() : FsEntry(nullptr) {}
  ~FsEntry() override;
  explicit PROTOBUF_CONSTEXPR FsEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FsEntry(const FsEntry& from);
  FsEntry(FsEntry&& from) noexcept
    : FsEntry() {
    *this = ::std::move(from);
  }

  inline FsEntry& operator=(const FsEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsEntry& operator=(FsEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FsEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const FsEntry* internal_default_instance() {
    return reinterpret_cast<const FsEntry*>(
               &_FsEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FsEntry& a, FsEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(FsEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FsEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FsEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FsEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FsEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FsEntry& from) {
    FsEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.FsEntry";
  }
  protected:
  explicit FsEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSizeFieldNumber = 3,
    kIsDirFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // bool is_dir = 2;
  void clear_is_dir();
  bool is_dir() const;
  void set_is_dir(bool value);
  private:
  bool _internal_is_dir() const;
  void _internal_set_is_dir(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.FsEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t size_;
    bool is_dir_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// -------------------------------------------------------------------

class FsOpResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:gridfs.FsOpResponse) */ {
 public:
  inline FsOpResponse() : FsOpResponse(nullptr) {}
  ~FsOpResponse() override;
  explicit PROTOBUF_CONSTEXPR FsOpResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FsOpResponse(const FsOpResponse& from);
  FsOpResponse(FsOpResponse&& from) noexcept
    : FsOpResponse() {
    *this = ::std::move(from);
  }

  inline FsOpResponse& operator=(const FsOpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FsOpResponse& operator=(FsOpResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FsOpResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FsOpResponse* internal_default_instance() {
    return reinterpret_cast<const FsOpResponse*>(
               &_FsOpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FsOpResponse& a, FsOpResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FsOpResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FsOpResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FsOpResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FsOpResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FsOpResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FsOpResponse& from) {
    FsOpResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FsOpResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "gridfs.FsOpResponse";
  }
  protected:
  explicit FsOpResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 3,
    kMessageFieldNumber = 2,
    kOkFieldNumber = 1,
  };
  // repeated .gridfs.FsEntry entries = 3;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::gridfs::FsEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gridfs::FsEntry >*
      mutable_entries();
  private:
  const ::gridfs::FsEntry& _internal_entries(int index) const;
  ::gridfs::FsEntry* _internal_add_entries();
  public:
  const ::gridfs::FsEntry& entries(int index) const;
  ::gridfs::FsEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gridfs::FsEntry >&
      entries() const;

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:gridfs.FsOpResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gridfs::FsEntry > entries_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BlockAssignment

// string block_id = 1;
inline void BlockAssignment::clear_block_id() {
  _impl_.block_id_.ClearToEmpty();
}
inline const std::string& BlockAssignment::block_id() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockAssignment.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockAssignment::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockAssignment.block_id)
}
inline std::string* BlockAssignment::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockAssignment.block_id)
  return _s;
}
inline const std::string& BlockAssignment::_internal_block_id() const {
  return _impl_.block_id_.Get();
}
inline void BlockAssignment::_internal_set_block_id(const std::string& value) {
  
  _impl_.block_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockAssignment::_internal_mutable_block_id() {
  
  return _impl_.block_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockAssignment::release_block_id() {
  // @@protoc_insertion_point(field_release:gridfs.BlockAssignment.block_id)
  return _impl_.block_id_.Release();
}
inline void BlockAssignment::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  _impl_.block_id_.SetAllocated(block_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_id_.IsDefault()) {
    _impl_.block_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockAssignment.block_id)
}

// string primary_dn = 2;
inline void BlockAssignment::clear_primary_dn() {
  _impl_.primary_dn_.ClearToEmpty();
}
inline const std::string& BlockAssignment::primary_dn() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockAssignment.primary_dn)
  return _internal_primary_dn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockAssignment::set_primary_dn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.primary_dn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockAssignment.primary_dn)
}
inline std::string* BlockAssignment::mutable_primary_dn() {
  std::string* _s = _internal_mutable_primary_dn();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockAssignment.primary_dn)
  return _s;
}
inline const std::string& BlockAssignment::_internal_primary_dn() const {
  return _impl_.primary_dn_.Get();
}
inline void BlockAssignment::_internal_set_primary_dn(const std::string& value) {
  
  _impl_.primary_dn_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockAssignment::_internal_mutable_primary_dn() {
  
  return _impl_.primary_dn_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockAssignment::release_primary_dn() {
  // @@protoc_insertion_point(field_release:gridfs.BlockAssignment.primary_dn)
  return _impl_.primary_dn_.Release();
}
inline void BlockAssignment::set_allocated_primary_dn(std::string* primary_dn) {
  if (primary_dn != nullptr) {
    
  } else {
    
  }
  _impl_.primary_dn_.SetAllocated(primary_dn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_dn_.IsDefault()) {
    _impl_.primary_dn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockAssignment.primary_dn)
}

// repeated string replica_dns = 3;
inline int BlockAssignment::_internal_replica_dns_size() const {
  return _impl_.replica_dns_.size();
}
inline int BlockAssignment::replica_dns_size() const {
  return _internal_replica_dns_size();
}
inline void BlockAssignment::clear_replica_dns() {
  _impl_.replica_dns_.Clear();
}
inline std::string* BlockAssignment::add_replica_dns() {
  std::string* _s = _internal_add_replica_dns();
  // @@protoc_insertion_point(field_add_mutable:gridfs.BlockAssignment.replica_dns)
  return _s;
}
inline const std::string& BlockAssignment::_internal_replica_dns(int index) const {
  return _impl_.replica_dns_.Get(index);
}
inline const std::string& BlockAssignment::replica_dns(int index) const {
  // @@protoc_insertion_point(field_get:gridfs.BlockAssignment.replica_dns)
  return _internal_replica_dns(index);
}
inline std::string* BlockAssignment::mutable_replica_dns(int index) {
  // @@protoc_insertion_point(field_mutable:gridfs.BlockAssignment.replica_dns)
  return _impl_.replica_dns_.Mutable(index);
}
inline void BlockAssignment::set_replica_dns(int index, const std::string& value) {
  _impl_.replica_dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gridfs.BlockAssignment.replica_dns)
}
inline void BlockAssignment::set_replica_dns(int index, std::string&& value) {
  _impl_.replica_dns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gridfs.BlockAssignment.replica_dns)
}
inline void BlockAssignment::set_replica_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replica_dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gridfs.BlockAssignment.replica_dns)
}
inline void BlockAssignment::set_replica_dns(int index, const char* value, size_t size) {
  _impl_.replica_dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gridfs.BlockAssignment.replica_dns)
}
inline std::string* BlockAssignment::_internal_add_replica_dns() {
  return _impl_.replica_dns_.Add();
}
inline void BlockAssignment::add_replica_dns(const std::string& value) {
  _impl_.replica_dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gridfs.BlockAssignment.replica_dns)
}
inline void BlockAssignment::add_replica_dns(std::string&& value) {
  _impl_.replica_dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gridfs.BlockAssignment.replica_dns)
}
inline void BlockAssignment::add_replica_dns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replica_dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gridfs.BlockAssignment.replica_dns)
}
inline void BlockAssignment::add_replica_dns(const char* value, size_t size) {
  _impl_.replica_dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gridfs.BlockAssignment.replica_dns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockAssignment::replica_dns() const {
  // @@protoc_insertion_point(field_list:gridfs.BlockAssignment.replica_dns)
  return _impl_.replica_dns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockAssignment::mutable_replica_dns() {
  // @@protoc_insertion_point(field_mutable_list:gridfs.BlockAssignment.replica_dns)
  return &_impl_.replica_dns_;
}

// -------------------------------------------------------------------

// BlockLocation

// string block_id = 1;
inline void BlockLocation::clear_block_id() {
  _impl_.block_id_.ClearToEmpty();
}
inline const std::string& BlockLocation::block_id() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockLocation.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockLocation::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockLocation.block_id)
}
inline std::string* BlockLocation::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockLocation.block_id)
  return _s;
}
inline const std::string& BlockLocation::_internal_block_id() const {
  return _impl_.block_id_.Get();
}
inline void BlockLocation::_internal_set_block_id(const std::string& value) {
  
  _impl_.block_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockLocation::_internal_mutable_block_id() {
  
  return _impl_.block_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockLocation::release_block_id() {
  // @@protoc_insertion_point(field_release:gridfs.BlockLocation.block_id)
  return _impl_.block_id_.Release();
}
inline void BlockLocation::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  _impl_.block_id_.SetAllocated(block_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_id_.IsDefault()) {
    _impl_.block_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockLocation.block_id)
}

// string primary_dn = 2;
inline void BlockLocation::clear_primary_dn() {
  _impl_.primary_dn_.ClearToEmpty();
}
inline const std::string& BlockLocation::primary_dn() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockLocation.primary_dn)
  return _internal_primary_dn();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockLocation::set_primary_dn(ArgT0&& arg0, ArgT... args) {
 
 _impl_.primary_dn_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockLocation.primary_dn)
}
inline std::string* BlockLocation::mutable_primary_dn() {
  std::string* _s = _internal_mutable_primary_dn();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockLocation.primary_dn)
  return _s;
}
inline const std::string& BlockLocation::_internal_primary_dn() const {
  return _impl_.primary_dn_.Get();
}
inline void BlockLocation::_internal_set_primary_dn(const std::string& value) {
  
  _impl_.primary_dn_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockLocation::_internal_mutable_primary_dn() {
  
  return _impl_.primary_dn_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockLocation::release_primary_dn() {
  // @@protoc_insertion_point(field_release:gridfs.BlockLocation.primary_dn)
  return _impl_.primary_dn_.Release();
}
inline void BlockLocation::set_allocated_primary_dn(std::string* primary_dn) {
  if (primary_dn != nullptr) {
    
  } else {
    
  }
  _impl_.primary_dn_.SetAllocated(primary_dn, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.primary_dn_.IsDefault()) {
    _impl_.primary_dn_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockLocation.primary_dn)
}

// repeated string replica_dns = 3;
inline int BlockLocation::_internal_replica_dns_size() const {
  return _impl_.replica_dns_.size();
}
inline int BlockLocation::replica_dns_size() const {
  return _internal_replica_dns_size();
}
inline void BlockLocation::clear_replica_dns() {
  _impl_.replica_dns_.Clear();
}
inline std::string* BlockLocation::add_replica_dns() {
  std::string* _s = _internal_add_replica_dns();
  // @@protoc_insertion_point(field_add_mutable:gridfs.BlockLocation.replica_dns)
  return _s;
}
inline const std::string& BlockLocation::_internal_replica_dns(int index) const {
  return _impl_.replica_dns_.Get(index);
}
inline const std::string& BlockLocation::replica_dns(int index) const {
  // @@protoc_insertion_point(field_get:gridfs.BlockLocation.replica_dns)
  return _internal_replica_dns(index);
}
inline std::string* BlockLocation::mutable_replica_dns(int index) {
  // @@protoc_insertion_point(field_mutable:gridfs.BlockLocation.replica_dns)
  return _impl_.replica_dns_.Mutable(index);
}
inline void BlockLocation::set_replica_dns(int index, const std::string& value) {
  _impl_.replica_dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:gridfs.BlockLocation.replica_dns)
}
inline void BlockLocation::set_replica_dns(int index, std::string&& value) {
  _impl_.replica_dns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:gridfs.BlockLocation.replica_dns)
}
inline void BlockLocation::set_replica_dns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replica_dns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gridfs.BlockLocation.replica_dns)
}
inline void BlockLocation::set_replica_dns(int index, const char* value, size_t size) {
  _impl_.replica_dns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gridfs.BlockLocation.replica_dns)
}
inline std::string* BlockLocation::_internal_add_replica_dns() {
  return _impl_.replica_dns_.Add();
}
inline void BlockLocation::add_replica_dns(const std::string& value) {
  _impl_.replica_dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gridfs.BlockLocation.replica_dns)
}
inline void BlockLocation::add_replica_dns(std::string&& value) {
  _impl_.replica_dns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:gridfs.BlockLocation.replica_dns)
}
inline void BlockLocation::add_replica_dns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.replica_dns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gridfs.BlockLocation.replica_dns)
}
inline void BlockLocation::add_replica_dns(const char* value, size_t size) {
  _impl_.replica_dns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gridfs.BlockLocation.replica_dns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockLocation::replica_dns() const {
  // @@protoc_insertion_point(field_list:gridfs.BlockLocation.replica_dns)
  return _impl_.replica_dns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockLocation::mutable_replica_dns() {
  // @@protoc_insertion_point(field_mutable_list:gridfs.BlockLocation.replica_dns)
  return &_impl_.replica_dns_;
}

// -------------------------------------------------------------------

// BlockChunk

// string block_id = 1;
inline void BlockChunk::clear_block_id() {
  _impl_.block_id_.ClearToEmpty();
}
inline const std::string& BlockChunk::block_id() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockChunk.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChunk::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockChunk.block_id)
}
inline std::string* BlockChunk::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockChunk.block_id)
  return _s;
}
inline const std::string& BlockChunk::_internal_block_id() const {
  return _impl_.block_id_.Get();
}
inline void BlockChunk::_internal_set_block_id(const std::string& value) {
  
  _impl_.block_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockChunk::_internal_mutable_block_id() {
  
  return _impl_.block_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockChunk::release_block_id() {
  // @@protoc_insertion_point(field_release:gridfs.BlockChunk.block_id)
  return _impl_.block_id_.Release();
}
inline void BlockChunk::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  _impl_.block_id_.SetAllocated(block_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_id_.IsDefault()) {
    _impl_.block_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockChunk.block_id)
}

// int64 seq = 2;
inline void BlockChunk::clear_seq() {
  _impl_.seq_ = int64_t{0};
}
inline int64_t BlockChunk::_internal_seq() const {
  return _impl_.seq_;
}
inline int64_t BlockChunk::seq() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockChunk.seq)
  return _internal_seq();
}
inline void BlockChunk::_internal_set_seq(int64_t value) {
  
  _impl_.seq_ = value;
}
inline void BlockChunk::set_seq(int64_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:gridfs.BlockChunk.seq)
}

// bytes data = 3;
inline void BlockChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& BlockChunk::data() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockChunk.data)
}
inline std::string* BlockChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockChunk.data)
  return _s;
}
inline const std::string& BlockChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void BlockChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockChunk::release_data() {
  // @@protoc_insertion_point(field_release:gridfs.BlockChunk.data)
  return _impl_.data_.Release();
}
inline void BlockChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockChunk.data)
}

// bool eof = 4;
inline void BlockChunk::clear_eof() {
  _impl_.eof_ = false;
}
inline bool BlockChunk::_internal_eof() const {
  return _impl_.eof_;
}
inline bool BlockChunk::eof() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockChunk.eof)
  return _internal_eof();
}
inline void BlockChunk::_internal_set_eof(bool value) {
  
  _impl_.eof_ = value;
}
inline void BlockChunk::set_eof(bool value) {
  _internal_set_eof(value);
  // @@protoc_insertion_point(field_set:gridfs.BlockChunk.eof)
}

// -------------------------------------------------------------------

// WriteAck

// string block_id = 1;
inline void WriteAck::clear_block_id() {
  _impl_.block_id_.ClearToEmpty();
}
inline const std::string& WriteAck::block_id() const {
  // @@protoc_insertion_point(field_get:gridfs.WriteAck.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAck::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.WriteAck.block_id)
}
inline std::string* WriteAck::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:gridfs.WriteAck.block_id)
  return _s;
}
inline const std::string& WriteAck::_internal_block_id() const {
  return _impl_.block_id_.Get();
}
inline void WriteAck::_internal_set_block_id(const std::string& value) {
  
  _impl_.block_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAck::_internal_mutable_block_id() {
  
  return _impl_.block_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAck::release_block_id() {
  // @@protoc_insertion_point(field_release:gridfs.WriteAck.block_id)
  return _impl_.block_id_.Release();
}
inline void WriteAck::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  _impl_.block_id_.SetAllocated(block_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_id_.IsDefault()) {
    _impl_.block_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.WriteAck.block_id)
}

// int64 bytes_received = 2;
inline void WriteAck::clear_bytes_received() {
  _impl_.bytes_received_ = int64_t{0};
}
inline int64_t WriteAck::_internal_bytes_received() const {
  return _impl_.bytes_received_;
}
inline int64_t WriteAck::bytes_received() const {
  // @@protoc_insertion_point(field_get:gridfs.WriteAck.bytes_received)
  return _internal_bytes_received();
}
inline void WriteAck::_internal_set_bytes_received(int64_t value) {
  
  _impl_.bytes_received_ = value;
}
inline void WriteAck::set_bytes_received(int64_t value) {
  _internal_set_bytes_received(value);
  // @@protoc_insertion_point(field_set:gridfs.WriteAck.bytes_received)
}

// string checksum = 3;
inline void WriteAck::clear_checksum() {
  _impl_.checksum_.ClearToEmpty();
}
inline const std::string& WriteAck::checksum() const {
  // @@protoc_insertion_point(field_get:gridfs.WriteAck.checksum)
  return _internal_checksum();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAck::set_checksum(ArgT0&& arg0, ArgT... args) {
 
 _impl_.checksum_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.WriteAck.checksum)
}
inline std::string* WriteAck::mutable_checksum() {
  std::string* _s = _internal_mutable_checksum();
  // @@protoc_insertion_point(field_mutable:gridfs.WriteAck.checksum)
  return _s;
}
inline const std::string& WriteAck::_internal_checksum() const {
  return _impl_.checksum_.Get();
}
inline void WriteAck::_internal_set_checksum(const std::string& value) {
  
  _impl_.checksum_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAck::_internal_mutable_checksum() {
  
  return _impl_.checksum_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAck::release_checksum() {
  // @@protoc_insertion_point(field_release:gridfs.WriteAck.checksum)
  return _impl_.checksum_.Release();
}
inline void WriteAck::set_allocated_checksum(std::string* checksum) {
  if (checksum != nullptr) {
    
  } else {
    
  }
  _impl_.checksum_.SetAllocated(checksum, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.checksum_.IsDefault()) {
    _impl_.checksum_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.WriteAck.checksum)
}

// bool ok = 4;
inline void WriteAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool WriteAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool WriteAck::ok() const {
  // @@protoc_insertion_point(field_get:gridfs.WriteAck.ok)
  return _internal_ok();
}
inline void WriteAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void WriteAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:gridfs.WriteAck.ok)
}

// string message = 5;
inline void WriteAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& WriteAck::message() const {
  // @@protoc_insertion_point(field_get:gridfs.WriteAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.WriteAck.message)
}
inline std::string* WriteAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:gridfs.WriteAck.message)
  return _s;
}
inline const std::string& WriteAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void WriteAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteAck::release_message() {
  // @@protoc_insertion_point(field_release:gridfs.WriteAck.message)
  return _impl_.message_.Release();
}
inline void WriteAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.WriteAck.message)
}

// -------------------------------------------------------------------

// BlockId

// string block_id = 1;
inline void BlockId::clear_block_id() {
  _impl_.block_id_.ClearToEmpty();
}
inline const std::string& BlockId::block_id() const {
  // @@protoc_insertion_point(field_get:gridfs.BlockId.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockId::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.BlockId.block_id)
}
inline std::string* BlockId::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:gridfs.BlockId.block_id)
  return _s;
}
inline const std::string& BlockId::_internal_block_id() const {
  return _impl_.block_id_.Get();
}
inline void BlockId::_internal_set_block_id(const std::string& value) {
  
  _impl_.block_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BlockId::_internal_mutable_block_id() {
  
  return _impl_.block_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BlockId::release_block_id() {
  // @@protoc_insertion_point(field_release:gridfs.BlockId.block_id)
  return _impl_.block_id_.Release();
}
inline void BlockId::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  _impl_.block_id_.SetAllocated(block_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_id_.IsDefault()) {
    _impl_.block_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.BlockId.block_id)
}

// -------------------------------------------------------------------

// HeartbeatKv

// string node_id = 1;
inline void HeartbeatKv::clear_node_id() {
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& HeartbeatKv::node_id() const {
  // @@protoc_insertion_point(field_get:gridfs.HeartbeatKv.node_id)
  return _internal_node_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatKv::set_node_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.node_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.HeartbeatKv.node_id)
}
inline std::string* HeartbeatKv::mutable_node_id() {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:gridfs.HeartbeatKv.node_id)
  return _s;
}
inline const std::string& HeartbeatKv::_internal_node_id() const {
  return _impl_.node_id_.Get();
}
inline void HeartbeatKv::_internal_set_node_id(const std::string& value) {
  
  _impl_.node_id_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartbeatKv::_internal_mutable_node_id() {
  
  return _impl_.node_id_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartbeatKv::release_node_id() {
  // @@protoc_insertion_point(field_release:gridfs.HeartbeatKv.node_id)
  return _impl_.node_id_.Release();
}
inline void HeartbeatKv::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  _impl_.node_id_.SetAllocated(node_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.HeartbeatKv.node_id)
}

// string key = 2;
inline void HeartbeatKv::clear_key() {
  _impl_.key_.ClearToEmpty();
}
inline const std::string& HeartbeatKv::key() const {
  // @@protoc_insertion_point(field_get:gridfs.HeartbeatKv.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatKv::set_key(ArgT0&& arg0, ArgT... args) {
 
 _impl_.key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.HeartbeatKv.key)
}
inline std::string* HeartbeatKv::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:gridfs.HeartbeatKv.key)
  return _s;
}
inline const std::string& HeartbeatKv::_internal_key() const {
  return _impl_.key_.Get();
}
inline void HeartbeatKv::_internal_set_key(const std::string& value) {
  
  _impl_.key_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartbeatKv::_internal_mutable_key() {
  
  return _impl_.key_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartbeatKv::release_key() {
  // @@protoc_insertion_point(field_release:gridfs.HeartbeatKv.key)
  return _impl_.key_.Release();
}
inline void HeartbeatKv::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  _impl_.key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.key_.IsDefault()) {
    _impl_.key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.HeartbeatKv.key)
}

// string value = 3;
inline void HeartbeatKv::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& HeartbeatKv::value() const {
  // @@protoc_insertion_point(field_get:gridfs.HeartbeatKv.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatKv::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.HeartbeatKv.value)
}
inline std::string* HeartbeatKv::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:gridfs.HeartbeatKv.value)
  return _s;
}
inline const std::string& HeartbeatKv::_internal_value() const {
  return _impl_.value_.Get();
}
inline void HeartbeatKv::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartbeatKv::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartbeatKv::release_value() {
  // @@protoc_insertion_point(field_release:gridfs.HeartbeatKv.value)
  return _impl_.value_.Release();
}
inline void HeartbeatKv::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.HeartbeatKv.value)
}

// int64 ts_unix_ms = 4;
inline void HeartbeatKv::clear_ts_unix_ms() {
  _impl_.ts_unix_ms_ = int64_t{0};
}
inline int64_t HeartbeatKv::_internal_ts_unix_ms() const {
  return _impl_.ts_unix_ms_;
}
inline int64_t HeartbeatKv::ts_unix_ms() const {
  // @@protoc_insertion_point(field_get:gridfs.HeartbeatKv.ts_unix_ms)
  return _internal_ts_unix_ms();
}
inline void HeartbeatKv::_internal_set_ts_unix_ms(int64_t value) {
  
  _impl_.ts_unix_ms_ = value;
}
inline void HeartbeatKv::set_ts_unix_ms(int64_t value) {
  _internal_set_ts_unix_ms(value);
  // @@protoc_insertion_point(field_set:gridfs.HeartbeatKv.ts_unix_ms)
}

// -------------------------------------------------------------------

// HeartbeatAck

// bool ok = 1;
inline void HeartbeatAck::clear_ok() {
  _impl_.ok_ = false;
}
inline bool HeartbeatAck::_internal_ok() const {
  return _impl_.ok_;
}
inline bool HeartbeatAck::ok() const {
  // @@protoc_insertion_point(field_get:gridfs.HeartbeatAck.ok)
  return _internal_ok();
}
inline void HeartbeatAck::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void HeartbeatAck::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:gridfs.HeartbeatAck.ok)
}

// string message = 2;
inline void HeartbeatAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HeartbeatAck::message() const {
  // @@protoc_insertion_point(field_get:gridfs.HeartbeatAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.HeartbeatAck.message)
}
inline std::string* HeartbeatAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:gridfs.HeartbeatAck.message)
  return _s;
}
inline const std::string& HeartbeatAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HeartbeatAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartbeatAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartbeatAck::release_message() {
  // @@protoc_insertion_point(field_release:gridfs.HeartbeatAck.message)
  return _impl_.message_.Release();
}
inline void HeartbeatAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.HeartbeatAck.message)
}

// -------------------------------------------------------------------

// FsOpRequest

// .gridfs.FsOpRequest.Op op = 1;
inline void FsOpRequest::clear_op() {
  _impl_.op_ = 0;
}
inline ::gridfs::FsOpRequest_Op FsOpRequest::_internal_op() const {
  return static_cast< ::gridfs::FsOpRequest_Op >(_impl_.op_);
}
inline ::gridfs::FsOpRequest_Op FsOpRequest::op() const {
  // @@protoc_insertion_point(field_get:gridfs.FsOpRequest.op)
  return _internal_op();
}
inline void FsOpRequest::_internal_set_op(::gridfs::FsOpRequest_Op value) {
  
  _impl_.op_ = value;
}
inline void FsOpRequest::set_op(::gridfs::FsOpRequest_Op value) {
  _internal_set_op(value);
  // @@protoc_insertion_point(field_set:gridfs.FsOpRequest.op)
}

// string path = 2;
inline void FsOpRequest::clear_path() {
  _impl_.path_.ClearToEmpty();
}
inline const std::string& FsOpRequest::path() const {
  // @@protoc_insertion_point(field_get:gridfs.FsOpRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FsOpRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.FsOpRequest.path)
}
inline std::string* FsOpRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:gridfs.FsOpRequest.path)
  return _s;
}
inline const std::string& FsOpRequest::_internal_path() const {
  return _impl_.path_.Get();
}
inline void FsOpRequest::_internal_set_path(const std::string& value) {
  
  _impl_.path_.Set(value, GetArenaForAllocation());
}
inline std::string* FsOpRequest::_internal_mutable_path() {
  
  return _impl_.path_.Mutable(GetArenaForAllocation());
}
inline std::string* FsOpRequest::release_path() {
  // @@protoc_insertion_point(field_release:gridfs.FsOpRequest.path)
  return _impl_.path_.Release();
}
inline void FsOpRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  _impl_.path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.path_.IsDefault()) {
    _impl_.path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.FsOpRequest.path)
}

// -------------------------------------------------------------------

// FsEntry

// string name = 1;
inline void FsEntry::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FsEntry::name() const {
  // @@protoc_insertion_point(field_get:gridfs.FsEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FsEntry::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.FsEntry.name)
}
inline std::string* FsEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:gridfs.FsEntry.name)
  return _s;
}
inline const std::string& FsEntry::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FsEntry::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FsEntry::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FsEntry::release_name() {
  // @@protoc_insertion_point(field_release:gridfs.FsEntry.name)
  return _impl_.name_.Release();
}
inline void FsEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.FsEntry.name)
}

// bool is_dir = 2;
inline void FsEntry::clear_is_dir() {
  _impl_.is_dir_ = false;
}
inline bool FsEntry::_internal_is_dir() const {
  return _impl_.is_dir_;
}
inline bool FsEntry::is_dir() const {
  // @@protoc_insertion_point(field_get:gridfs.FsEntry.is_dir)
  return _internal_is_dir();
}
inline void FsEntry::_internal_set_is_dir(bool value) {
  
  _impl_.is_dir_ = value;
}
inline void FsEntry::set_is_dir(bool value) {
  _internal_set_is_dir(value);
  // @@protoc_insertion_point(field_set:gridfs.FsEntry.is_dir)
}

// int64 size = 3;
inline void FsEntry::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t FsEntry::_internal_size() const {
  return _impl_.size_;
}
inline int64_t FsEntry::size() const {
  // @@protoc_insertion_point(field_get:gridfs.FsEntry.size)
  return _internal_size();
}
inline void FsEntry::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void FsEntry::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:gridfs.FsEntry.size)
}

// -------------------------------------------------------------------

// FsOpResponse

// bool ok = 1;
inline void FsOpResponse::clear_ok() {
  _impl_.ok_ = false;
}
inline bool FsOpResponse::_internal_ok() const {
  return _impl_.ok_;
}
inline bool FsOpResponse::ok() const {
  // @@protoc_insertion_point(field_get:gridfs.FsOpResponse.ok)
  return _internal_ok();
}
inline void FsOpResponse::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void FsOpResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:gridfs.FsOpResponse.ok)
}

// string message = 2;
inline void FsOpResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& FsOpResponse::message() const {
  // @@protoc_insertion_point(field_get:gridfs.FsOpResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FsOpResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:gridfs.FsOpResponse.message)
}
inline std::string* FsOpResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:gridfs.FsOpResponse.message)
  return _s;
}
inline const std::string& FsOpResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void FsOpResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* FsOpResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* FsOpResponse::release_message() {
  // @@protoc_insertion_point(field_release:gridfs.FsOpResponse.message)
  return _impl_.message_.Release();
}
inline void FsOpResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:gridfs.FsOpResponse.message)
}

// repeated .gridfs.FsEntry entries = 3;
inline int FsOpResponse::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int FsOpResponse::entries_size() const {
  return _internal_entries_size();
}
inline void FsOpResponse::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::gridfs::FsEntry* FsOpResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:gridfs.FsOpResponse.entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gridfs::FsEntry >*
FsOpResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:gridfs.FsOpResponse.entries)
  return &_impl_.entries_;
}
inline const ::gridfs::FsEntry& FsOpResponse::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::gridfs::FsEntry& FsOpResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:gridfs.FsOpResponse.entries)
  return _internal_entries(index);
}
inline ::gridfs::FsEntry* FsOpResponse::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::gridfs::FsEntry* FsOpResponse::add_entries() {
  ::gridfs::FsEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:gridfs.FsOpResponse.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::gridfs::FsEntry >&
FsOpResponse::entries() const {
  // @@protoc_insertion_point(field_list:gridfs.FsOpResponse.entries)
  return _impl_.entries_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace gridfs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::gridfs::FsOpRequest_Op> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gridfs::FsOpRequest_Op>() {
  return ::gridfs::FsOpRequest_Op_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_common_2eproto
